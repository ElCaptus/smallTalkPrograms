Object subclass: #JobDescription	instanceVariableNames: 'effort priority description'	classVariableNames: ''	poolDictionaries: ''	category: 'Objetos1-JobSchedulerToRefactor'!!JobDescription commentStamp: 'Casco 8/11/2018 13:50' prior: 0!I describe a job to be done. I cannot be called Job (altough that is a better name) becasue a class with that name already exists in Smalltalk.!!JobDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!effort: anObject	effort := anObject! !!JobDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!effort	^ effort! !!JobDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!priority	^ priority! !!JobDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!description: anObject	description := anObject! !!JobDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!description	^ description! !!JobDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!priority: anObject	priority := anObject! !Object subclass: #JobScheduler	instanceVariableNames: 'jobs strategy'	classVariableNames: ''	poolDictionaries: ''	category: 'Objetos1-JobSchedulerToRefactor'!!JobScheduler commentStamp: 'Casco 8/11/2018 13:50' prior: 0!I schedule jobs.I know that I am badly designed!!!!JobScheduler methodsFor: 'accessing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!jobs	^ jobs! !!JobScheduler methodsFor: 'accessing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!strategy	^ strategy! !!JobScheduler methodsFor: 'accessing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!next	| sortedJobs next |	self strategy = 'FIFO'		ifTrue: [ next := self jobs first.			self unschedule: next.			^ next ].	self strategy = 'LIFO'		ifTrue: [ next := self jobs last.			self unschedule: next.			^ next ].	self strategy = 'Priority'		ifTrue: [ sortedJobs := self jobs asSortedCollection: [ :a :b | a priority > b priority ].			next := sortedJobs removeFirst.			self unschedule: next.			^ next ].	self strategy = 'MostEffortFirst'		ifTrue: [ sortedJobs := self jobs asSortedCollection: [ :a :b | a effort > b effort ].			next := sortedJobs removeFirst.			self unschedule: next.			^ next ]! !!JobScheduler methodsFor: 'accessing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!strategy: anObject	strategy := anObject! !!JobScheduler methodsFor: 'initialize' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!initialize   jobs := OrderedCollection new. ! !!JobScheduler methodsFor: 'schedulling' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!unschedule: job	jobs remove: job! !!JobScheduler methodsFor: 'schedulling' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!schedule: job	jobs add: job! !TestCase subclass: #JobSchedulerTest	instanceVariableNames: 'firstJob highestPriorityJob mostEffortJob lastJob'	classVariableNames: ''	poolDictionaries: ''	category: 'Objetos1-JobSchedulerToRefactor'!!JobSchedulerTest commentStamp: 'Casco 8/11/2018 13:15' prior: 0!I test JobScheduler!!JobSchedulerTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!testNext	| scheduler |	scheduler := JobScheduler new.	scheduler strategy: 'FIFO'.	self scheduleJobsIn: scheduler.	self assert: scheduler next == firstJob.	self assert: scheduler jobs size == 3.		scheduler := JobScheduler new.	scheduler strategy: 'LIFO'.	self scheduleJobsIn: scheduler.	self assert: scheduler next == lastJob.	self assert: scheduler jobs size == 3.	scheduler := JobScheduler new.		scheduler strategy: 'Priority'.	self scheduleJobsIn: scheduler.	self assert: scheduler next == highestPriorityJob.	self assert: scheduler jobs size == 3.	scheduler := JobScheduler new.		scheduler strategy: 'MostEffortFirst'.	self scheduleJobsIn: scheduler.	self assert: scheduler next == mostEffortJob.	self assert: scheduler jobs size == 3! !!JobSchedulerTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!testSchedule	| scheduler |	scheduler := JobScheduler new.	scheduler schedule: highestPriorityJob.	self assert: (scheduler jobs includes: highestPriorityJob )! !!JobSchedulerTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!testUnschedule	| scheduler |	scheduler := JobScheduler new.	self scheduleJobsIn: scheduler.	scheduler unschedule: highestPriorityJob.	self deny: (scheduler jobs includes: highestPriorityJob)! !!JobSchedulerTest methodsFor: 'running' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!setUp	self initializieJobs.! !!JobSchedulerTest methodsFor: 'private' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!scheduleJobsIn: aScheduler	aScheduler		schedule: firstJob;		schedule: highestPriorityJob;		schedule: mostEffortJob;		schedule: lastJob! !!JobSchedulerTest methodsFor: 'private' stamp: 'CompatibleUserName 8/21/2019 14:50:07'!initializieJobs	firstJob := JobDescription  new.	firstJob		priority: 1;		description: 'Este es el primero';		effort: 1.	highestPriorityJob := JobDescription new.	highestPriorityJob		priority: 100;		description: 'Este es el de mas prioridad';		effort: 1.	mostEffortJob := JobDescription new.	mostEffortJob		priority: 1;		description: 'Este es el de mas prioridad';		effort: 100.	lastJob := JobDescription new.	lastJob		priority: 1;		description: 'Este es el de mas prioridad';		effort: 1! !